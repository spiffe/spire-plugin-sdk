syntax = "proto3";
package spire.plugin.server.keymanager.v1;
option go_package = "github.com/spiffe/spire-plugin-sdk/proto/spire/plugin/server/keymanager/v1;keymanagerv1";

service KeyManager {
    // Generates a new private key with the given ID. If a key already exists
    // under that ID, it is be overwritten. The fingerprint of the overwritten
    // key is different than the original.
    rpc GenerateKey(GenerateKeyRequest) returns (GenerateKeyResponse);

    // Gets the public key information for private key managed by the plugin
    // with the given ID.  If a key with the given ID does not exist, NOT_FOUND
    // is returned.
    rpc GetPublicKey(GetPublicKeyRequest) returns (GetPublicKeyResponse);

    // Gets all public key information for private keys managed by the plugin.
    rpc GetPublicKeys(GetPublicKeysRequest) returns (GetPublicKeysResponse);

    // Signs data with the private key with the given ID and fingerprint.  If a
    // key with the given ID does not exist or has a different fingerprint,
    // NOT_FOUND is returned.
    rpc SignData(SignDataRequest) returns (SignDataResponse);
}

message PublicKey {
    // Required. The ID of the key, as provided when the key was created.
    string id = 1;

    // Required. The type of the key.
    KeyType type = 2;

    // Required. The public key data (PKIX encoded).
    bytes pkix_data = 3;

    // Required. Fingerprint of the public key. The (id,fingerprint) tuple
    // represents a unique identifier for the key. The fingerprint is used to
    // ensure that a signing operation is taking place with the intended key
    // (see SignData). Plugins are welcome to choose their fingerprinting
    // algorithm. A naive implementation is a hash over the PKIX data.
    string fingerprint = 4;
}

message GenerateKeyRequest {
    // Required. The ID to give the generated key (or to identify the existing
    // key to overwrite (see GenerateKey).
    string key_id = 1;

    // Required. The type of the key to generate.
    KeyType key_type = 2;
}

message GenerateKeyResponse {
    // Required. The generated key.
    PublicKey public_key = 1;
}

message GetPublicKeyRequest {
    // Required. The ID of the key to retrieve.
    string key_id = 1;
}

message GetPublicKeyResponse {
    // Required. The public key to return.
    PublicKey public_key = 1;
}

message GetPublicKeysRequest {
}

message GetPublicKeysResponse {
    // Required. The public keys managed by the KeyManager. May be empty.
    repeated PublicKey public_keys = 1;
}

message SignDataRequest {
    message PSSOptions {
        // Required. The salt length.
        int32 salt_length = 1;

        // Required. The hash algorithm.
        HashAlgorithm hash_algorithm = 2;
    }

    // Required. The ID of the key to use to sign the data.
    string key_id = 1;

    // Required. The fingerprint of the key to use to sign the data.
    string key_fingerprint = 2;

    // Required. The data so sign.
    bytes data = 3;

    // Required. The signature options. The PSS options is only valid
    // for RSA keys.
    oneof signer_opts {
        HashAlgorithm hash_algorithm = 4;
        PSSOptions pss_options = 5;
    }
}

message SignDataResponse {
    // Required. The signature of the data.
    bytes signature = 1;
}

enum KeyType {
    UNSPECIFIED_KEY_TYPE = 0;
    EC_P256 = 1;
    EC_P384 = 2;
    RSA_1024 = 3;
    RSA_2048 = 4;
    RSA_4096 = 5;
}

enum HashAlgorithm {
    UNSPECIFIED_HASH_ALGORITHM = 0;
    // These entries (and their values) line up with a subset of the go
    // crypto.Hash constants
    SHA224 = 4;
    SHA256 = 5;
    SHA384 = 6;
    SHA512 = 7;
    SHA3_224 = 10;
    SHA3_256 = 11;
    SHA3_384 = 12;
    SHA3_512 = 13;
    SHA512_224 = 14;
    SHA512_256 = 15;
}
